# Epic 6: Reporting, Export & MVP Polish

**Expanded Goal:** Implement (Phase 2) PDF report generation for jobs via Cloud Function, add offline sync status visibility with queue indicators, enhance UI polish (loading states, error messages, empty states), and deliver final QA pass for production readiness. This epic transforms the functional MVP into a polished, production-ready application.

### Story 6.1: PDF Report Generation Cloud Function (Phase 2)

**As a** craftsman,
**I want** to export job reports as PDF with costs breakdown and financial summary,
**so that** I can send professional documentation to clients.

**Acceptance Criteria:**

1. Job Detail screen has "Export PDF" button (icon: download/document)
2. Button tap calls Cloud Function (HTTPS callable): `generateJobPDF({jobId})`
3. Function queries job, costs (all categories), advances from Firestore
4. Function uses pdfmake library to generate PDF with:
   - Header: Job title, jobNumber, status, date range (createdAt to now)
   - Costs section: Table with columns: Category, Description, Amount, Date (grouped by category with subtotals)
   - Total Costs: Sum of all costs
   - Advances section: Table with columns: Advance #, Amount, Date, Note
   - Total Advances: Sum of all advances
   - **Net Due: (Total Costs - Total Advances)** highlighted in bold
   - Footer: "Generated by FinDogAI on [date]" with branding
5. Function returns PDF as base64-encoded string or Firebase Storage URL
6. App displays PDF preview (in-app viewer or browser tab)
7. App provides "Share" button → opens native share sheet (email, messaging apps, save to files)
8. Email option pre-fills subject: "Job Report - [jobNumber] [title]" with PDF attached
9. Function execution time: <5 seconds for typical job (<100 costs)
10. Error handling: If function fails, show: "PDF generation failed. Try again later."
11. Offline mode: "Export PDF" button disabled with tooltip: "Requires internet connection"
12. PDF export is owner-only (button only visible to owner)

### Story 6.2: Offline Sync Status Visibility

**As a** user,
**I want** clear visual indicators of offline mode and pending sync operations,
**so that** I know when my data is syncing to the cloud.

**Acceptance Criteria:**

1. Top status bar (or within Active Job Banner) displays connectivity indicator: "🟢 Online" or "🟠 Offline"
2. Offline mode shows additional info: "Offline - X items pending sync" (X = queued Firestore writes)
3. When app reconnects, indicator briefly shows: "🔄 Syncing..." with spinner
4. After successful sync: "✓ Synced" message displays for 3 seconds, then returns to "🟢 Online"
5. If sync fails (e.g., Security Rules rejection, network timeout), show: "⚠️ Sync issues - [X] items pending" with "Retry" button
6. Tapping "Retry" button manually triggers Firestore sync attempt
7. Sync queue detailed view (optional expandable): Lists pending operations: "Job #123 - Update pending", "Cost #45 - Create pending"
8. Firestore offline persistence enabled in app init (already required from Epic 1, validating here)
9. Sync status persists across app restarts: Pending writes resume when app reopens
10. Testing: Enable airplane mode, create job/cost, re-enable network → verify sync completes and status updates
11. Sync status uses minimal battery: Checks connectivity passively (network status events, not polling)
12. Empty state: If online with no pending writes, just show "🟢 Online" (no clutter)
13. Header shows AI status badge aligned with connectivity: when online and AI disabled → "🟢 Online · AI Disabled"; when offline and AI enabled → "🟠 Offline · AI Unavailable"
14. AI status badge appears in the same area as connectivity (top status bar or within Active Job Banner), coalescing into a single line without overlapping UI
15. Tapping the AI status badge opens a tooltip explaining current state and next actions: if disabled → "Enable AI in Settings › Person Profile"; if offline → "Reconnect to enable AI features"



### Story 6.3: Offline Sync Conflict Resolution (MVP)

**As a** user,
**I want** my offline edits to sync safely even when others changed the same data,
**so that** I don't lose work and can resolve conflicts when they happen.

**Acceptance Criteria:**

1. All mutable entities (jobs, vehicles, machines, teamMembers, costs, advances, events) include `createdAt`, `createdBy` (compound identity object), `updatedAt` (serverTimestamp), `updatedBy` (compound identity object)
2. Conflict policy: Last-Write-Wins (LWW) at document level; Firestore's built-in conflict resolution applies (later serverTimestamp wins); no auto-merge at field level for MVP
3. Delete vs Update conflict: Jobs use soft delete (`status: archived`) to avoid destructive deletes; for other entities (vehicles, machines, teamMembers, costs, advances, events), if a server-side delete precedes an offline update, the update fails on sync and appears in Sync Issues UI with actions: Discard, Recreate as new
4. Sequential numbers never conflict: Numbers assigned only by Cloud Functions (allocateSequence HTTPS callable for online; onCreate triggers for offline); offline-created items show placeholder '—' until sync assigns number; no duplicates possible
5. Sync Issues UI (extends Story 6.2 sync status): Lists failed writes with human-readable reason (e.g., "Document deleted on server", "Permission denied", "Network timeout"); actions per item: Discard (delete local pending write), Retry (re-attempt sync), Recreate (save as new document when applicable)
6. Visual feedback: When LWW overwrites a local change after sync, the final state is displayed without crash; user can review change history via audit logs for that document (audit logs include before/after snapshots)
7. Partial sync failures: If some documents succeed and others fail during a batch sync, successful writes are committed; failed writes remain in pending queue and appear in Sync Issues UI; user can retry failed items individually or in batch
8. Emulator tests:
   - Two devices edit the same job title offline; both reconnect; the later serverTimestamp write wins; app remains stable on both devices; audit logs show both updates
   - Device A deletes a cost (hard delete); Device B edits it offline; on sync, B sees a Sync Issue: "Document deleted on server" with options to Discard or Recreate as new cost
   - Offline create with placeholder number receives a proper sequential number on sync with no duplicates; UI updates from '—' to assigned number
   - Create 10 jobs offline, sync with 3 failures (e.g., permission denied); verify 7 succeed, 3 appear in Sync Issues with Retry option
9. No data loss: Pending writes persist across app restarts; sync queue is durable (Firestore offline persistence handles this)
10. Owner override: If a non-owner user's offline write fails due to role/status changes (e.g., membership disabled while offline), Sync Issues shows "Permission denied" with explanation; user can contact owner to restore access or discard the change

### Story 6.4: UI Polish - Loading States & Skeleton Screens

**As a** user,
**I want** smooth loading experiences with skeleton screens instead of spinners,
**so that** the app feels fast and responsive.

**Acceptance Criteria:**

1. Jobs List screen displays skeleton screens (gray pulsing placeholders) while loading from Firestore
2. Skeleton matches job card layout: Rectangle for jobNumber/title, smaller rectangles for status/financial summary
3. Job Detail screen shows skeleton for costs/advances/events tabs while loading
4. Voice Confirmation Modal shows loading spinner during STT/LLM/TTS processing with label: "Transcribing...", "Understanding...", "Confirming..."
5. Form submissions (create/update job, cost, resource) show button loading state: spinner inside button, button disabled, label: "Saving..."
6. Successful operations show brief success feedback (checkmark icon + toast message: "Job created") before dismissing
7. Error states use toast notifications (red background, error icon, clear message) that auto-dismiss after 5 seconds with manual dismiss option (X button)
8. Empty states (no jobs, no costs, no resources) use friendly illustrations + action-oriented text: "No jobs yet. Create your first job!" with large CTA button
9. Image loading (future: if receipts/photos added) uses blur-up technique (tiny thumbnail → full image)
10. All loading states tested: Slow 3G simulation (Chrome DevTools) to verify skeleton screens appear and transitions are smooth
11. No jarring layout shifts (Content Layout Shift - CLS score <0.1 in Lighthouse)
12. Loading states respect accessibility: Screen readers announce "Loading jobs" / "Jobs loaded"

### Story 6.5: Error Handling & User Feedback Polish

**As a** user,
**I want** clear, actionable error messages when things go wrong,
**so that** I know what happened and how to fix it.

**Acceptance Criteria:**



1. Network errors: "Network error. Check your connection and try again."
2. Firestore permission denied errors: "Access denied. Your account may not have permission for this action."
3. Voice recognition errors: "Could not understand. Please try again." (with Retry button)
4. API quota exceeded (STT/LLM/TTS): "Service temporarily unavailable. Try again in a few minutes."
5. Validation errors inline on forms (red text below field): "Job title is required", "Budget must be a positive number"
6. Delete confirmations use clear language: "Delete job #123 'Smith, Brno'? This cannot be undone." with "Cancel" (default focus) and "Delete" (red, requires tap)
7. Unsaved changes warning: If user navigates away from form with edits, show: "Discard unsaved changes?" with Cancel/Discard options
8. Session expiration: If Firebase Auth token expires, show: "Session expired. Please log in again." and redirect to login
9. No generic errors: Replace "Error: undefined" with meaningful messages
10. Error logging: All errors logged to console (dev) or analytics service (prod) for debugging, including stack traces
11. Retry mechanisms: Network-related errors include "Retry" button that re-attempts operation
12. User-tested: Run app with intentional errors (delete non-existent job, exceed API quota via mocking) to validate messages are clear

### Story 6.6: Final QA Pass & Production Readiness Checklist

**As a** PM,
**I want** a comprehensive QA validation of all MVP features,
**so that** we can confidently deploy to production.

**Acceptance Criteria:**

1. **Functional Testing:** All user stories from Epics 1-6 manually tested and passing
2. **Voice Flows:** Core voice flows (Set Active Job, Start Journey, End Journey, Add Material Cost, Record Work Hours, Quick Expense) tested with realistic variations (different phrasings, Czech + English, numeric/text identifiers, hands-free "yes"/"no" confirmation responses) — baseline end-to-end success ≥80% in controlled conditions; report WER (median/P95), intent F1, and numeric exact-match; improvements tracked post-MVP
2a. **Hands-Free Confirmation:** Validate voice confirmation works: speak command → hear TTS → say "yes" → action executes without touch; say "no" → retry flow; touch buttons remain functional as fallback
2b. **Voice Error Handling:** Test all error scenarios from Story 3.7: network timeout, low STT confidence, unrecognized intent, storage full, battery critical, wrong language, missing entities — verify clear error messages and recovery options (Retry/Manual Entry/Cancel)
2c. **Inline Job Targeting:** Validate commands with "for job [id/name]" apply to the specified job without changing the Active Job; TTS/modal include targeted job label

3. **Offline Testing:** Airplane mode scenarios validated: Create job/cost offline → sync on reconnection → verify data on second device
4. **Multi-Device Sync:** Same tenant logged in on phone + tablet → changes on one device appear on other within 10 seconds
5. **Role/Access Enforcement:** Test user with restricted role or disabled status cannot access financial data or add costs (UI + API)
6. **Security Rules:** Attempt cross-tenant data access (User A tries to read User B's jobs) → permission denied
7. **Performance:** Lighthouse audit scores: Performance >80, Accessibility >90, Best Practices >90, SEO >80
8. **PWA Requirements:** App installable, works offline, has app manifest and service worker (Firebase Hosting handles this)
9. **Capacitor Builds:** Android APK builds successfully, installs on test device, all features functional (microphone, offline, etc.)
10. **Error Handling:** No unhandled exceptions in console during 30-minute usage session
11. **Data Integrity:** Sequential IDs (jobNumber, vehicleNumber, etc.) are unique and strictly increasing per scope across 100+ creates; no duplicates; gaps allowed (e.g., deletes/rollbacks). Offline-created records receive IDs on sync.
12. **Audit Logging:** Verify audit logs created for all CRUD operations, TTL cleanup function executes successfully
13. **Browser Compatibility:** Tested on Chrome, Edge, Safari (iOS + desktop) - all features work
14. **Load Testing (Basic):** 10 concurrent users creating jobs/costs → no errors, acceptable latency (<2s for writes)
15. **Production Deployment:** Deploy to Firebase Hosting + Functions, accessible at production URL, all env variables configured
16. **Conflict Resolution Testing:** Validate Story 6.3 scenarios: concurrent edits (LWW), delete-vs-update conflicts (Sync Issues UI), offline sequential ID allocation (no duplicates), partial sync failures (retry mechanism)
17. **Post-Deployment Smoke Test (MVP):** Register new user → create job → add cost via voice → all steps succeed. Note: PDF export is Phase 2 and will be verified when Story 6.1 lands (skipped in MVP).
18. **Rollback Plan:** Document rollback procedure if critical bugs found post-launch

---

### **Rationale for Epics 4-6:**

**Epic 4 (Journey Tracking & Cost Management):**
- Completes the "cost capture" value proposition (voice + manual for all categories)
- Start + End Journey form the core travel pair (safety + odometer tracking); Material/Labor/Quick Expense voice capture targets the highest-frequency daily operations
- Manual cost entry provides fallback and correction mechanism (critical for MVP trust)
- Advances tracking rounds out job financials (costs - advances = net due)

**Epic 5 (Audit Logging & Compliance):**
- Backend-heavy, can be developed in parallel with Epic 4 UX work
- Audit triggers are "set and forget" (minimal ongoing maintenance)
- Privilege enforcement prepares MVP for team use (Phase 2 readiness)
- Compliance features (audit logs, GDPR-ready) are table stakes for EU market

**Epic 6 (Polish & Production Readiness):**
- PDF export (Phase 2) is minimum viable billing artifact (replaces complex invoicing post-MVP)
- Offline sync visibility addresses user anxiety ("Is my data saved?")
- UI polish transforms functional MVP into production-quality app
- QA checklist ensures confident launch (no critical bugs slip through)

**Sequential Dependencies:**
- Epic 4 requires Epic 3 (voice pipeline) and Epic 2 (resources)
- Epic 5 can start after Epic 2 (data model exists) - parallel to Epic 4
- Epic 6 requires Epics 1-5 complete (polishes the complete feature set)

---

**Phasing & MVP Scope (6 months, 1–2 devs):** MVP includes Epics 1–4 plus essential slices of Epics 5 and 6 (5.1 audit triggers, 5.5 Security Rules; 6.2 offline sync status, 6.3 conflict resolution, 6.6 final QA).

Phase 2 includes: advanced permissions (beyond MVP roles), OAuth (beyond email/password), PDF generation (Issue #11), invoicing/billing integration, deeper UI polish, approval workflows for large expenses, and job-specific/time-bound permissions.

**Next steps:**
1. Execute PM Checklist
2. Generate handoff prompts for UX Expert and Architect

Ready to proceed? Type **1** to continue with PM Checklist execution.